---
title: "Introduction to ggDoubleHeat"
output: rmarkdown::html_vignette
author: "Trent Buskirk, Youzhi Yu"
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{Introduction to ggDoubleHeat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 8, 
  fig.height = 5,
  comment = "#>"
)
```

The *ggDoubleHeat* package is a ggplot2 extension. *ggDoubleHeat* plots are reformed heat maps that compare two sets of values with shared data attributes. They can be quite useful for visualizing data from two different sources with at least four dimensions in total, and can be generated in conjunction with using *ggplot2* at ease. 

## How to use the package?

### Meet the `geom_heat_*()` family

All functions in *ggDoubleHeat* are named `geom_heat_*()` for consistency. Unlike a typical `geom_*()`function in ggplot2, all data variables do not need `aes()` when using `geom_heat_*()`, allowing plots having different color renderings internally. 

Before generating any plot, it is necessary to introduce one of the built-in data sets in the package `pitts_tg`. This data set includes Google and Twitter COVID-related searches and tweets (with keywords included in the 9 categories) incidence rate respectively in the Pittsburgh Metropolitan Statistical Area (MSA) in a 30-week period. For complete data introduction, just type `?pitts_tg` at the console.

Here is the structure of the data set: 


```{r setup}
library(ggplot2)
library(ggDoubleHeat)
pitts_tg

```

`week`, `category`, `Twitter`, and `Google` are the four columns we need.

#### **I. geom_heat_grid()**

```{r}
library(dplyr)
pitts_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_grid(outside = Google, inside = Twitter)
```

If we think the colors on the above heatgrid get washed out, `trans = "sqrt"` is a good option to adjust the scale for `fill`.

```{r}
pitts_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_grid(outside = Google, inside = Twitter, trans = "sqrt")
```

`trans = "sqrt"` here is equivalent to `scale_x/y_sqrt()` but for `fill`.

If we want to decrease the area of the inside, `r` should be increased.

```{r}
pitts_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_grid(outside = Google, inside = Twitter, r = 5)
```

The larger `r` is, the samller the inside turns out to be. Note: `r` has to be greater than 2. 


*ggplot2* by default gives some padding (margins) around the plot. *ggDoubleHeat* provides a nifty function `remove_padding()` to help remove it and thus make the plot take up the entire plot space.

```{r}
pitts_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_grid(outside = Google, inside = Twitter) +
  remove_padding()
```

#### **II. geom_heat_circle()**

By replacing `geom_heat_grid()` with `geom_heat_circle()`, 

```{r}
pitts_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_circle(outside = Google, inside = Twitter)
```

#### **III. geom_heat_tri()**

```{r}
pitts_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_tri(lower = Google, upper = Twitter)
```

Unlike `geom_heat_grid/circle()` sharing the exact same arguments, `geom_heat_tri()` has slightly different arguments than the previous two `geom_heat_*()` functions. Instead of using `outside` and `inside`, it has `lower` and `upper`. Also, `r` does not exist in this function. Users can figure out why this is the case. 

Now we can tidy the heatgrid up:

```{r}
pitts_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_grid(outside = Google, inside = Twitter, trans = "sqrt",
                 labels = scales::percent_format(scale = 1)) +
  theme_heat() +
  remove_padding() +
  labs(title = "Pittsburgh Google & Twitter Incidence Rate")
```

`theme_heat()` is a theme provided by the package.


## When to use the package?

Without *ggDoubleHeat*, one of the heatmap-like ways to visualize `pitts_tg` is:

```{r}
library(tidyr)
pitts_tg %>%
  pivot_longer(cols = c(Twitter:Google), names_to = "source", values_to = "incidence_rate") %>%
  ggplot(aes(week, category, fill = incidence_rate)) +
  geom_tile() +
  facet_wrap(~source)
```


When looking at the faceted plot, we immediately recognize it is not easy to compare Google and Twitter incidence rate for a specific week and a specific category, as they are far apart from each other. `geom_heat_*()` in essence combines the faceted plots into one integral plot, while making it much easier to compare the difference among Google/Twitter incidence rates. 


So far, we have only visualized the incidence rates in Pittsburgh. Since we mentioned faceting above, it is time to make a heatgrid with multiple states involved.

`states_tg` is another data set in the package, providing Google and Twitter incidence rate for 4 states in the U.S., and it has the exact same data structure as `pitts_tg`. For more information, just type `?states_tg` at the console. 

```{r fig.height=5, fig.width=8}
states_tg %>%
  ggplot(aes(week, category)) +
  geom_heat_grid(outside = Google, inside = Twitter, r = 4, trans = "sqrt") +
  facet_wrap(~state) 
```

We have been discussing using the package to compare two data sources, but the other way to think about using *ggDoubleHeat* is when comparing mean and median of a single source. Letâ€™s use the following `iris` example to demonstrate it:

```{r}
iris_summarized <- iris %>%
  pivot_longer(c(1:4), names_to = "metric") %>%
  group_by(Species, metric) %>%
  summarize(mean = mean(value),
            median = median(value)) %>%
  ungroup()

iris_summarized
```

A common way to visualize `iris_summarized` is as follows:

```{r}
iris_summarized %>%
  pivot_longer(c(mean:median), names_to = "summary_metric") %>%
  ggplot(aes(value, Species, fill = summary_metric)) +
  geom_col(position = "dodge") +
  facet_wrap(~metric) +
  labs(fill = NULL)
```

Now we can use heatgrid to visualize the summarized data:

```{r}
iris_summarized %>%
  ggplot(aes(Species, metric)) +
  geom_heat_grid(outside = mean, inside = median)
```

Here we see the mean and median across all sections are close within each grid. Otherwise, some stark difference would be caught by our eyes, thus giving us a rough picture of how data is distributed. 

Usually, mean and median are not visualized on the same plot, but visualizing them on the same plot can give viewers important information on whether data has outliers on one side or the other. Using heatgrid can make such visualization easy and effective. 

## Why to use the package?

As all the code shown above, it is rather easy to use `geom_heat_*()` as long as users know how to use *ggplot2*, and the *ggDoubleHeat* plots offer some handy visual comparison for data on par with each other. All these plots are at least one dimension higher than a conventional heat map. Making them is effortless, as the package inherits ggplot2 features. 






